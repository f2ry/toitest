<html lang="en">
<head>
  <title>Кодирование информации</title>
  <link rel="stylesheet" href="../style.css">
</head>
<header>
  <ul>
    <li onclick="location.href = '../index.html'">Оглавление</li>
    <li onclick="location.href = '../glossariy.html'">Глоссарий</li>
    <li onclick="location.href = '../schemes.html'">Блок-схемы</li>
    <li onclick="location.href = '../questions.html'">Вопросы по теме</li>
    <li onclick="location.href = '../tasks.html'">Задачи по теме</li>
    <li onclick="location.href = '../sources.html'">Доп. источники</li>
    <li id="title" onclick="location.href = '../index.html'">Кодирование. От и до.</li>
  </ul>
</header>
<body>
  <h1>Кодирование информации</h1>
  <p class="description">
    Этот раздел посвящен кодированию информации, которое играет важную роль в обработке, передачи и хранении данных.
  </p>

  <div class="text-block">
    <h2 class="block-title">1. Определение и цели кодирования</h2>
    <p class="main-block-text">
      Сначала определим, что вообще есть кодирование. Итак..
    </p>
    <details class="definition" style="margin-top: -30px;">
      <summary>Кодирование</summary>
      <p>Кодирование есть перевод информации, представленной посредством первичного алфавита, в последовательность кодов. Разделяют <i>алфавитное, блочное, и двоичное</i> кодирование. </p>
    </details>
    <p class="main-block-text">
      Говоря проще, кодирование - процесс преобразования данных <i class="highlight">из одной формы представления в другую</i>.
      <br>
      Перечислим основные цели кодирования:
    </p>
    <ul class="text-list">
      <li>
        <b>Эффективность хранения:</b> С одной стороны, кодирование позволяет уменьшать объем данных для для экономии места на носителях. Позже мы рассмотрим это в пункте "Сжатие информации".
      </li>
      <li>
        <b>Скорость передачи:</b> Кодирование позволяет ускорить передачу данных по каналам связи.
      </li>
      <li>
        <b>Защита информации:</b> Также кодирование позволяет обеспечить конфиденциальность и целостность данных. Первое подробнее изучается в шифровании, а второе мы попробуем разобрать позже.
      </li>
      <li>
        <b>Устойчивость к ошибкам:</b> К предыдущему пункту, кодирование обеспечивает возможность восстановления данных в случае их повреждения. Об этом тоже позже.
      </li>
    </ul>
    <br>
    <p class="main-block-text">
      Банальнейшим примером можно привести кодирование текстовой информации в двоичном виде. Такое кодирование позволяет компьютерам обрабатывать и хранить текстовые данные. Да и не только текстовые...
    </p>
  </div>

  <div class="text-block">
    <h2 class="block-title">2. Двоичное кодирование</h2>
    <p class="main-block-text">
      Итак, двоичное кодирование. Сначала определение:
    </p>
    <details class="definition" style="margin-top: -30px;">
      <summary>Двоичное кодирование</summary>
      <p>Под двоичным кодированием понимается метод представления информации с использованием двух символов, обычно 0 и 1, представляя каждый исходный символ уникальной последовательностью битов.</p>
    </details>
    <p class="main-block-text">
      Зачем вообще нужно двоичное кодирование? На самом деле этот метод - основа цифровой информации, которая используется в компьютерных системах для представления и обработки данных. 
      <br>
      Рассмотрим некоторые пункты необходимости этого метода:
    </p>
    <ul class="text-list">
      <li>
        <b>Совместимость с цифровыми устройствами</b>: так как компьютеры и прочие цифровые устройства работают на основе электрических сигналов, которые могут принимать два состояния (ВКЛ и ВЫКЛ, 0 и 1, как угодно), то двоичное кодирование идеально подходит для представления этих двух состояний.
      </li>
      <li>
        <b>Устойчивость к ошибкам</b>: позже мы разберем некоторые методы коррекции ошибок, которые очень хорошо применимы к двоичной системе, которая позволяет легко обнаруживать и исправлять ошибки.
      </li>
      <li>
        <b>Простота обработки</b>: в двоичной системе легко реализуются такие операции, как: AND, OR, NOT, XOR - основы логики. Это упрощает процесс обработки данных в компьютере.
      </li>
      <li>
        <b>Эффективность хранения</b>: двоичное кодирование позволяет эффективно использовать память, так как каждый символ или число может быть закодировано в минимально возможном количестве битов.
      </li>
      <br>
      <p class="main-block-text">
        Выше уже было упомянуто, что двоичное кодирование хорошо сочетается со всеми компьютерными штуками. <i class="highlight">Сетевые протоколы, микропроцессоры, хранение данных</i> и всё, всё, всё...
        <br>
        <b>Интересный факт:</b> несмотря на то, что минимальной единицей информации в объемном подходе является бит, в основном в современности используются <i class="highlight">байты</i>, состоящие из восьми бит. Делается это для удобства работы с данными, всё-таки в эпоху Больших Данных живём. Один байт может представлять аж 256 различных значений (от 0 до 255), что позволяет кодировать буквы и цифры в текстовых файлах (да и не только в них...). 
      </p>
    </ul>
  </div>

  <div class="text-block">
    <h2 class="block-title">3. Неравномерное кодирование</h2>
    <details class="definition" style="margin-top: -30px;">
      <summary>Неравномерный код</summary>
      <p>
        Неравномерным кодом называется такой код, который формирует кодовые комбинации <i>разной</i> длины.
      </p>
    </details>
    <p class="main-block-text">
      Использование неравномерного кодирования сильно упрощает жизнь тогда, когда требуется максимальная экономия места. Впрочем, ошибки в неравномерном коде недопустимы от слова совсем. Так, если в коде будет допущена хотя бы одна ошибка, то с огромной вероятность восстановить всю следующую последовательность будет невозможно, из-за чего всё сообщение будет утеряно.
      <br>
      Разберем пару алгоритмов неравномерного кодирования сообщений.
    </p>
      <div class="text-block" style="border-color: rgb(0, 255, 0);">
        <details>
        <summary style="color: white;background-color: black; max-width: 400px; padding: 15px; font-size: 24px; cursor: pointer;">
          1. Алгоритм Хаффмана.
        </summary>
        <details class="definition" style="margin-top: -30px;">
          <summary>Алгоритм Хаффмана</summary>
          <p>Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью.</p>
        </details>  
        <p class="main-block-text" style="border: none; max-width: 100%;">
          Этот алгоритм был разработан <i class="highlight">Дэвидом Хаффманом</i> в 1952 году при написании им курсовой работы. В настоящее время он используется во многих программах сжатия данных.
          <br>
          Сам метод состоит из двух этапов: <i class="highlight">построение оптимального кодового дерева</i> и <i class="highlight">построение отображения код-символ</i> на основе построенного дерева.
          <br>
          Итак, у нас есть строка: "beep boop beer!". В текущем виде она занимает 120 бит (по 8 бит на каждый символ). После кодирования строка займёт 40 бит.
          Чтобы получить код для каждого символа на основе его частотности, нам надо построить бинарное дерево, такое, что каждый лист этого дерева будет содержать символ (печатный знак из строки). Дерево будет строиться от листьев к корню, в том смысле, что символы с меньшей частотой будут дальше от корня, чем символы с большей. Скоро вы увидите, для чего это нужно.
          <br>
          Чтобы построить дерево, мы воспользуемся слегка модифицированной очередью с приоритетами — первыми из неё будут извлекаться элементы с наименьшим приоритетом, а не наибольшим. Это нужно, чтобы строить дерево от листьев к корню.
          <br>
          Для начала посчитаем частоты всех символов:
        </p>
        <table>
          <tr class="table-header">
            <th>
              Символ
            </th>
            <th>
              Частота
            </th>
          </tr>
          <tr>
            <td>'b'</td>
            <td>3</td>
          </tr>
          <tr>
            <td>'e'</td>
            <td>4</td>
          </tr>
          <tr>
            <td>'p'</td>
            <td>2</td>
          </tr>
          <tr>
            <td>''</td>
            <td>2</td>
          </tr>
          <tr>
            <td>'o'</td>
            <td>2</td>
          </tr>
          <tr>
            <td>'r'</td>
            <td>1</td>
          </tr>
          <tr>
            <td>'!'</td>
            <td>1</td>
          </tr>
        </table>
      <p class="main-block-text" style="border: none; max-width: 100%;">
        После вычисления частот создадим узлы бинарного дерева для каждого знака и добавим их в очередь, используя частоту в качестве приоритета:
        <img src="../imgs/haffman/1.png" alt="!!!" class="text-image">
        Теперь достаем два первых элемента из очереди и связываем их, создавая новый узел дерева, в котором они оба будут потомками, а приоритет нового узла будет равен сумме их приоритетов. После этого добавим получившийся новый узел обратно в очередь.
        <img src="../imgs/haffman/2.png" alt="!!!" class="text-image">
        Последовательно повторяя те же шаги, получим (не торопитесь и тщательно обработайте эту информацию):
        <img src="../imgs/haffman/3.png" alt="!!!" class="text-image">
        <img src="../imgs/haffman/4.png" alt="!!!" class="text-image">
        <img src="../imgs/haffman/5.png" alt="!!!" class="text-image">
        <img src="../imgs/haffman/6.png" alt="!!!" class="text-image">
        После того, как мы свяжем два последних элемента, получится итоговое дерево:
        <img src="../imgs/haffman/7.png" alt="!!!" class="text-image">
        Теперь, чтобы получить код для каждого символа, надо просто пройтись по дереву и для каждого перехода добавлять 0, если идём влево, и 1 - если вправо:
        <img src="../imgs/haffman/8.png" alt="!!!" class="text-image">
        Если мы так сделаем, то получим следующие коды для символов:
      </p>
      <table>
        <tr class="table-header">
          <th>
            Символ
          </th>
          <th>
            Код
          </th>
        </tr>
        <tr>
          <td>'b'</td>
          <td>00</td>
        </tr>
        <tr>
          <td>'e'</td>
          <td>11</td>
        </tr>
        <tr>
          <td>'p'</td>
          <td>101</td>
        </tr>
        <tr>
          <td>''</td>
          <td>011</td>
        </tr>
        <tr>
          <td>'o'</td>
          <td>010</td>
        </tr>
        <tr>
          <td>'r'</td>
          <td>1000</td>
        </tr>
        <tr>
          <td>'!'</td>
          <td>1001</td>
        </tr>
      </table>
      <p class="main-block-text" style="border: none; max-width: 100%;">
        Чтобы расшифровать закодированную строку, нам надо, соответственно, просто идти по дереву, сворачивая в соответствующую каждому биту сторону до тех пор, пока мы не достигнем листа. Например, если есть строка «101 11 101 11» и наше дерево, то мы получим строку «pepe».
        <br>
        Важно иметь в виду, что <i class="highlight">каждый код не является префиксом для кода другого символа</i>. В нашем примере, если 00 — это код для 'b', то 000 не может оказаться чьим-либо кодом, потому что иначе мы получим конфликт. Мы никогда не достигли бы этого символа в дереве, так как останавливались бы ещё на 'b'.
        <br>
        На практике, при реализации данного алгоритма сразу после построения дерева строится таблица Хаффмана. Данная таблица, по сути, — связный список или массив, который содержит каждый символ и его код, потому что это делает кодирование более эффективным. Довольно затратно каждый раз искать символ и одновременно вычислять его код, так как мы не знаем, где он находится, и придётся обходить всё дерево целиком. Как правило, для кодирования используется таблица Хаффмана, а для декодирования — дерево Хаффмана.
        <br> 
        Входная строка: «beep boop beer!»
        Входная строка в бинарном виде: «0110 0010 0110 0101 0110 0101 0111 0000 0010 0000 0110 0010 0110 1111 0110 1111 0111 0000 0010 0000 0110 0010 0110 0101 0110 0101 0111 0010 0010 000»
        <br>
        Закодированная строка: «0011 1110 1011 0001 0010 1010 1100 1111 1000 1001»
        <br>
        Как вы можете заметить, между ASCII-версией строки и закодированной версией существует большая разница.
      </p>
      </details>
      </div>
      
      <div class="text-block" style="border-color: rgb(0, 255, 0);">
        <details>
          <summary style="color: white;background-color: black; max-width: 400px; padding: 15px; font-size: 24px; cursor: pointer;">
            2. Алгоритм Шеннона-Фано.
          </summary>
          <p class="main-block-text" style="border: none; max-width: 100%;">
            Этот алгоритм имеет больше сходство с алгоритмом Хаффмана, которыый появился на несколько лет позже. Алгоритм также использует коды переменной длины: часто встречающийся символ коируется кодом меньшей длины, редко встречающийся - кодом большей длины. Эти коды также префиксные, то есть никакое кодовое слово не является префиксом любого другого. <i class="highlight">Именно это свойство позволяет однозначно декодировать любую последовательность кодовых слов.</i>
            <br>
            Алгоритм назван в честь Шеннона и Фано, потому что был разработан ими независимо друг от друга. Шеннон опубликовал его в "Математической теории связи", а Фано - просто в техническом отчёте.
            <br>
            Состоит из 4 основных этапов:
          </p>
          <ul class="text-list">
            <li>
              Символы первичного алфавита выписывают по убыванию вероятностей.
            </li>
            <li>
              Символы полученного алфавита делят на две части, суммарные вероятности символов которых максимально близки друг другу. <i>Так, две части таблицы по вероятностям должны быть примерно равны друг другу.</i>
            </li>
            <li>
              В префиксном коде для первой части алфавита присваивается "0", второй части - "1".
            </li>
            <li>
              Полученные части рекурсивно делятся, их частям назначаются цифры согласно предыдущему пункту.
            </li>
          </ul>
          <br>
          <p class="main-block-text" style="border: none; max-width: 100%;">
            Код Шеннона — Фано строится с помощью дерева. Построение этого дерева начинается от корня. Всё множество кодируемых элементов соответствует корню дерева (вершине первого уровня). Оно разбивается на два подмножества с примерно одинаковыми суммарными вероятностями. Эти подмножества соответствуют двум вершинам второго уровня, которые соединяются с корнем. Далее каждое из этих подмножеств разбивается на два подмножества с примерно одинаковыми суммарными вероятностями. Им соответствуют вершины третьего уровня. Если подмножество содержит единственный элемент, то ему соответствует концевая вершина кодового дерева; такое подмножество разбиению не подлежит. Подобным образом поступаем до тех пор, пока не получим все концевые вершины. Ветви кодового дерева размечаем символами 1 и 0, как в случае кода Хаффмана.
            <br>
            При построении кода Шеннона — Фано разбиение множества элементов может быть произведено, вообще говоря, несколькими способами. Выбор разбиения на уровне n может ухудшить варианты разбиения на следующем уровне (n + 1) и привести к неоптимальности кода в целом. Другими словами, оптимальное поведение на каждом шаге пути ещё не гарантирует оптимальности всей совокупности действий. Поэтому код Шеннона — Фано не является оптимальным в общем смысле, хотя и дает оптимальные результаты при некоторых распределениях вероятностей. Для одного и того же распределения вероятностей можно построить, вообще говоря, несколько кодов Шеннона — Фано, и все они могут дать различные результаты. Если построить все возможные коды Шеннона — Фано для данного распределения вероятностей, то среди них будут находиться и все коды Хаффмана, то есть оптимальные коды.
            <br>
            Ниже приведем простой пример кодового дерева.
            <br>
            Исходные символы:
          </p>
          <ul class="text-list">
            <li>A (частота встречаемости: 50)</li>
            <li>B (частота встречаемости: 39)</li>
            <li>C (частота встречаемости: 18)</li>
            <li>D (частота встречаемости: 49)</li>
            <li>E (частота встречаемости: 35)</li>
            <li>F (частота встречаемости: 24)</li>
          </ul>
          <img src="../imgs/shannon_tree.png" alt="" class="text-image">
        <p class="main-block-text" style="border: none; max-width: 100%;">
          Полученный код: A — 11, B — 101, C — 100, D — 00, E — 011, F — 010.
          <br>
          Кодирование Шеннона — Фано является достаточно старым методом сжатия, и на сегодняшний день оно не представляет особого практического интереса. В большинстве случаев длина последовательности, сжатой по данному методу, равна длине сжатой последовательности с использованием кодирования Хаффмана. Но на некоторых последовательностях могут сформироваться неоптимальные коды Шеннона — Фано, поэтому более эффективным считается сжатие методом Хаффмана.
        </p>
        </details>
      </div>
      <br>
    <p class="main-block-text">
      Оба рассмотренных выше алгоритма используются в т.ч. и для <i>архивации</i> данных, т.е. сжатия.
      <br>
      Отдельно стоит упомянуть условие Фано, имеющее непосредственное отношение к понятию неравномерного кодирования.
      <details class="definition">
        <summary>Условие Фано</summary>
        <p>
          Звучит оно примерно так: <i>"Никакое кодовое слово не может быть началом другого кодового слова"</i>.
        </p>
      </details>
    </p>
    <p class="main-block-text">
      Это условие хорошо заметно в описанных выше алгоритмах, которые являются префиксными. <i>А ещё это условие часто встречается в ЕГЭшных задачах...</i>
      <br>
      Стоит упомянуть, что это условие всегда соблюдается в равномерном кодировании, что, впрочем, очень даже логично.
      <br>
      Примером кода, удовлетворяющего условию Фано, являются телефонные номера в традиционной телефонии. Если в сети существует номер 101, то номер 1012345 не может быть выдан: при наборе трёх цифр АТС прекращает понимать дальнейший набор и соединяет с адресатом по номеру 101. Однако в сотовой телефонной сети это правило уже не действует, поскольку требуется завершение последовательности знаков соответствующей кнопкой (обычно — с изображением зелёной трубки), при этом 101, 1010 и 1012345 могут одновременно пониматься как разные адресаты.
    </p>
  </div>

  <div class="text-block">
    <h2 class="block-title">4. Равномерное кодирование</h2>
    <p class="main-block-text">
      Противоположным предыдущему явление - равномерное кодирование.
    </p>
    <details class="definition" style="margin-top: -30px;">
      <summary>Равномерный код</summary>
      <p>
        Равномерным кодом называется такой код, который формирует для всех символов первичного алфавита комбинации <i>одинаковой</i> длины.
      </p>
    </details>
    <p class="main-block-text">
      Такое кодирование явно является менее эффективным относительно работы с памятью, но, тем не менее, оно сильно упрощает процесс декодирования сообщения.
      <br>
      Даже текст, который вы сейчас читаете, является примером равномерного кодирования и последующего декодирования. Это кодировка UTF-8, широко используемая везде и всюду. Каждый символ - восьмизначный двоичный код, саму таблицу UTF-8 вы можете найти на просторах Интернета.
      <br>
      В целом, равномерный код всегда однозначно декодируется, поскольку всё сообщение разбивается на "кусочки", - блоки - каждому из которых однозначно соответствует символ в кодировочной таблице. Подробнее можете почитать <i class="highlight"><a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2,_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B_%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA" style="color: rgb(255, 0, 0); text-decoration: none;">тут</a></i>.
    </p>
  </div>

  <div class="text-block">
    <h2 class="block-title">5. Сжатие данных</h2>
    <details class="definition" style="margin-top: -30px;">
      <summary>Сжатие данных</summary>
      <p>
        Сжатием называется процесс уменьшения объема информации, который может быть достигнут с помощью различных алгоритмов.
      </p>
    </details>
    <p class="main-block-text">
      Существует два основных типа сжатия: <i class="highlight">сжатие без потерь</i> и <i class="highlight">сжатие с потерями</i>.
      <br>
      Ярким примером сжатия без потерь является архивация данных: так, формат .ZIP использует сжатие без потерь, позволяя полностью восстановить исходные данные. 
      <br>
      Примером сжатия с потерями является формат .JPEG: он сжимает изображения с потерями, удаляя детали, которые не замечает наш глаз. Говоря проще, он "шакалит" картинку. Пример ниже. 
      <img src="../imgs/JPEG_example_down.jpg" alt="" class="text-image" style="max-width: 600px;">
      Слева направо степень сжатия изображения уменьшается, вы можете заметить, что оно становится чётче.
      <br>
      Таблица основных форматов сжатия с указанием типов сжатия (с потерями или без):
    </p>
    <table style="margin-bottom: 10px;">
      <tr class="table-header">
        <th>
          Формат
        </th>
        <th>
          Тип сжатия
        </th>
        <th>
          Применение
        </th>
      </tr>
      <tr>
        <td>JPEG</td>
        <td>С потерями</td>
        <td>Изображения</td>
      </tr>
      <tr>
        <td>PNG</td>
        <td>Без потерь</td>
        <td>Изображения</td>
      </tr>
      <tr>
        <td>MP3</td>
        <td>С потерями</td>
        <td>Аудиофайлы</td>
      </tr>
      <tr>
        <td>WAV</td>
        <td>Без потерь</td>
        <td>Аудиофайлы</td>
      </tr>
      <tr>
        <td>ZIP</td>
        <td>Без потерь</td>
        <td>Архивирование файлов</td>
      </tr>
    </table>
    <p class="main-block-text">
      Подводя итоги: сжатие без потерь используют тогда, когда нужны все исходные данные. Сжатие с потерями используют тогда, когда есть часть данных, потеря которых несущественна с точки зрения их дальнейшего использования.
    </p>
    <a class="move-button" href="04_errors.html">Следующая страница</a>
  </div>
</body>

<footer>
  <p style="color: white; float: right; margin-right: 20px;">by <i style="color: red;"><a href="https://t.me/ixmtwo" style="text-decoration: none; color: inherit;">ixmtwo</a></i> w/ <i style="color: rgb(0, 255, 0);"><a href="https://t.me/rnbnablesse" style="text-decoration: none; color: inherit;">blessed</a> & <a href="https://t.me/v3ncher" style="text-decoration: none; color: inherit;">v3ncher</a></i></p>
</footer>